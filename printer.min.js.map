{"version":3,"file":"printer.js","names":["global","factory","exports","module","define","amd","self","jsonlintPrinter","this","noop","isIdentifierName","value","test","concatenateTokens","tokens","outputString","tokenCount","length","tokenIndex","raw","print","options","Error","indentString","indent","Array","join","prettyPrint","undefined","pruneComments","stripObjectKeys","enforceDoubleQuotes","enforceSingleQuotes","trimTrailingCommas","foundLineBreak","addedLineBreak","needsLineBreak","addedSpace","needsSpace","indentLevel","scopes","scopeType","isValue","token","tokenType","tokenContent","peekAtNextToken","nextTokenIndex","nextToken","type","addIndent","i","addLineBreak","addDelayedSpaceOrLineBreak","addStandaloneComment","tryAddingInlineComment","tryTokenIndex","skipWhitespace","indexOf","substr","addLiteral","tokenValue","JSON","stringify","replace","openScope","push","closeScope","pop","addComma","addColon","Object","defineProperty"],"sources":["lib/printer.js"],"sourcesContent":["(function (global, factory) {\n  // eslint-disable-next-line no-unused-expressions, multiline-ternary\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)\n  // eslint-disable-next-line no-undef, multiline-ternary\n    : typeof define === 'function' && define.amd ? define('jsonlint-printer', ['exports'], factory)\n    // eslint-disable-next-line no-undef\n      : (global = global || self, factory(global.jsonlintPrinter = {}))\n}(this, function (exports) {\n  'use strict'\n\n  function noop () {}\n\n  function isIdentifierName (value) {\n    return /^[a-zA-Z$_][a-zA-Z0-9$_]*$/.test(value)\n  }\n\n  function concatenateTokens (tokens) {\n    let outputString = ''\n    const tokenCount = tokens.length\n    let tokenIndex\n    for (tokenIndex = 0; tokenIndex < tokenCount; ++tokenIndex) {\n      outputString += tokens[tokenIndex].raw\n    }\n    return outputString\n  }\n\n  function print (tokens, options) {\n    if (!(tokens && tokens.length)) {\n      throw new Error('JSON tokens missing.')\n    }\n    // Whitespace and comments are available only as raw token content.\n    if (!(tokens[0] && tokens[0].raw)) {\n      throw new Error('JSON tokens lack raw values.')\n    }\n\n    if (!options) {\n      // If no options, not even an empty object is passed, just concatenate\n      // the raw tokens with neither minification, nor pretty-printing.\n      return concatenateTokens(tokens)\n    }\n\n    let indentString = options.indent\n    if (typeof indentString === 'number') {\n      indentString = new Array(indentString + 1).join(' ')\n    }\n    // Setting the indent to an empty string enables pretty-printing too.\n    // It will just insert line breaks without any indentation.\n    const prettyPrint = indentString !== undefined\n    const pruneComments = options.pruneComments\n    const stripObjectKeys = options.stripObjectKeys\n    const enforceDoubleQuotes = options.enforceDoubleQuotes\n    const enforceSingleQuotes = options.enforceSingleQuotes\n    const trimTrailingCommas = options.trimTrailingCommas\n\n    let outputString = ''\n    let foundLineBreak, addedLineBreak, needsLineBreak\n    let addedSpace, needsSpace\n    let indentLevel = 0\n    const scopes = []\n    let scopeType\n    let isValue\n    const tokenCount = tokens.length\n    let tokenIndex, token, tokenType, tokenContent\n\n    function peekAtNextToken () {\n      let nextTokenIndex = tokenIndex\n      let nextToken\n      do {\n        nextToken = tokens[++nextTokenIndex]\n      } while (nextToken && (nextToken.type === 'whitespace' ||\n                             nextToken.type === 'comment'))\n      return nextToken\n    }\n\n    let addIndent\n    if (prettyPrint && indentString) {\n      addIndent = function () {\n        for (let i = 0; i < indentLevel; ++i) {\n          outputString += indentString\n        }\n      }\n    } else {\n      addIndent = noop\n    }\n\n    let addLineBreak, addDelayedSpaceOrLineBreak\n    if (prettyPrint) {\n      addLineBreak = function () {\n        outputString += '\\n'\n      }\n\n      addDelayedSpaceOrLineBreak = function () {\n        // A line break is more important than a space.\n        if (needsLineBreak) {\n          addLineBreak()\n          addIndent()\n        } else if (needsSpace) {\n          outputString += ' '\n        }\n        needsSpace = needsLineBreak = false\n      }\n    } else {\n      addLineBreak = addDelayedSpaceOrLineBreak = noop\n    }\n\n    let addStandaloneComment, tryAddingInlineComment\n    if (pruneComments) {\n      addStandaloneComment = tryAddingInlineComment = noop\n    } else {\n      if (prettyPrint) {\n        addStandaloneComment = function () {\n          // If a comment is not appended to the end of a line, it will start\n          // on a new line with the current indentation.\n          if (!addedLineBreak && tokenIndex > 0) {\n            addLineBreak()\n            addIndent()\n          }\n          outputString += tokenContent\n          foundLineBreak = false\n          addedLineBreak = false\n          // If a comment is not appended to the end of a line, it will take\n          // the whole line and has to end by a line break.\n          needsLineBreak = true\n        }\n\n        tryAddingInlineComment = function () {\n          // This function is called after printing a non-line-break character.\n          foundLineBreak = false\n          addedLineBreak = false\n          addedSpace = false\n\n          // Start with the character after the just processed one.\n          let tryTokenIndex = tokenIndex + 1\n\n          function skipWhitespace () {\n            let token = tokens[tryTokenIndex]\n            if (token && token.type === 'whitespace') {\n              foundLineBreak = token.raw.indexOf('\\n') >= 0\n              token = tokens[++tryTokenIndex]\n            }\n            return token\n          }\n\n          const token = skipWhitespace()\n          // If line break followed the previous token, leave the comment\n          // to be handled by the next usual token processing.\n          if (!foundLineBreak && token && token.type === 'comment') {\n            if (needsLineBreak) {\n              // If the previous non-whitespace token was ended by a line\n              // break, retain it. Print the comment after the line break too.\n              if (!addedLineBreak) {\n                addLineBreak()\n                addIndent()\n              }\n            } else {\n              // If the previous non-whitespace token was not ended by a line\n              // break, ensure that the comment is separated from it.\n              if (!addedSpace) {\n                outputString += ' '\n              }\n            }\n            outputString += token.raw\n            // Set the current token to the just processed comment.\n            tokenIndex = tryTokenIndex++\n            // Check the whitespace after the comment to give a hint\n            // about the next whitespace to the further processing.\n            skipWhitespace()\n            if (foundLineBreak) {\n              needsSpace = false\n              needsLineBreak = true\n            } else {\n              needsSpace = true\n              needsLineBreak = false\n            }\n          }\n        }\n      } else {\n        // If all whitespace is omitted, convert single-line comments\n        // to multi-line ones, which include a comment-closing token.\n        addStandaloneComment = function () {\n          if (tokenContent[1] === '/') {\n            outputString += '/*'\n            outputString += tokenContent.substr(2, tokenContent.length - 2)\n            outputString += ' */'\n          } else {\n            outputString += tokenContent\n          }\n        }\n\n        tryAddingInlineComment = noop\n      }\n    }\n\n    function addLiteral () {\n      addDelayedSpaceOrLineBreak()\n      const tokenValue = token.value\n      if (stripObjectKeys && scopeType === '{' && !isValue &&\n          isIdentifierName(tokenValue)) {\n        outputString += tokenValue\n      } else if (typeof tokenValue === 'string') {\n        if (enforceDoubleQuotes && tokenContent[0] !== '\"') {\n          outputString += JSON.stringify(tokenValue)\n        } else if (enforceSingleQuotes && tokenContent[0] !== '\\'') {\n          outputString += '\\'' + tokenValue.replace(/'/g, '\\\\\\'') + '\\''\n        } else {\n          outputString += tokenContent\n        }\n      } else {\n        outputString += tokenContent\n      }\n      tryAddingInlineComment()\n    }\n\n    function openScope () {\n      addDelayedSpaceOrLineBreak()\n      scopes.push(scopeType)\n      scopeType = tokenContent\n      isValue = scopeType === '['\n      outputString += tokenContent\n      tryAddingInlineComment()\n      ++indentLevel\n      needsLineBreak = true\n    }\n\n    function closeScope () {\n      scopeType = scopes.pop()\n      addLineBreak()\n      --indentLevel\n      addIndent()\n      needsSpace = needsLineBreak = false\n      outputString += tokenContent\n      tryAddingInlineComment()\n    }\n\n    function addComma () {\n      if (trimTrailingCommas) {\n        const nextToken = peekAtNextToken()\n        if (nextToken && nextToken.type === 'symbol') {\n          return tryAddingInlineComment()\n        }\n      }\n      addDelayedSpaceOrLineBreak()\n      outputString += ','\n      tryAddingInlineComment()\n      addLineBreak()\n      addIndent()\n      addedLineBreak = true\n      needsLineBreak = false\n      isValue = scopeType === '['\n    }\n\n    function addColon () {\n      addDelayedSpaceOrLineBreak()\n      outputString += ':'\n      needsSpace = true\n      tryAddingInlineComment()\n      isValue = true\n    }\n\n    for (tokenIndex = 0; tokenIndex < tokenCount; ++tokenIndex) {\n      token = tokens[tokenIndex]\n      tokenType = token.type\n      tokenContent = token.raw\n      switch (tokenType) {\n        case 'literal':\n          addLiteral()\n          break\n        case 'comment':\n          addStandaloneComment()\n          break\n        case 'symbol':\n          switch (tokenContent) {\n            case '{':\n            case '[':\n              openScope()\n              break\n            case '}':\n            case ']':\n              closeScope()\n              break\n            case ',':\n              addComma()\n              break\n            case ':':\n              addColon()\n          }\n          break\n        default: // whitespace\n          foundLineBreak = tokenContent.indexOf('\\n') >= 0\n      }\n    }\n\n    return outputString\n  }\n\n  exports.print = print\n\n  Object.defineProperty(exports, '__esModule', { value: true })\n}))\n"],"mappings":"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"}